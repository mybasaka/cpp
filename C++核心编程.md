# C++核心编程

---

本阶段主要针对C++==面向对象技术==进行解释，探讨C+编程技术中的核心和精髓

## 1 内存分区模型

C++程序在执行时，将内存大方向划分为4个区域

* 代码区：存放函数体的二进制代码，由操作系统进行管理的
* 全局区：存放全局变量和静态变量以及常量
* 栈区：由编译器自动分配释放，存放函数的参数值，局部变量，*局部常量*
* 堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收

**程序四区的意义：**

不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活编程

### 1.1 程序运行前

在程序编译后，生成了exe可执行程序，未执行程序前分为两个区域

**代码区：**

​		存放CPU执行的机器指令

​		代码区是**共享**的，共享的目的是对于频繁执行的程序，只需要在内存中有一份代码即可

​		代码区是**只读**的，只读的原因是防止程序意外地修改了它的指令。

**全局区：**

​		全局变量和静态变量存放在此处

​		全局区包含了常量区、字符串常量和其他常量也存放在此

​		==该区域的数据在程序结束之后由操作系统释放==

### 1.2 程序运行后

**栈区：**

​		由编译器自动分配释放、存放函数的参数值、局部变量等

​		注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放

**堆区：**

​		由程序员分配释放，若程序员不释放，程序结束时由操作系统回收

​		在C++中主要利用new在堆区中开辟数据

### 1.3 new操作符

**语法：** `new 数据类型`利用new创建数据，会返回该数据对应类型的指针

`int * p = new int(10)`指针本身是一个局部变量，指针是在栈上的，但是new出来的内容是堆上的内容，直到delete操作或者程序结束。

## 2 引用

### 2.1 引用的基本使用

**作用：**给变量起别名

**语法：**`数据类型 &别名 = 原名`

### 2.2 引用的注意事项

* 引用必须初始化
* 引用在初始化之后不可以被改变

### 2.3 引用做函数的参数

**作用：**函数传参时，可以利用引用的技术让形参修饰实参

**优点：**可以简化指针修改实参

**示例：**

```c++
//1.值传递
void myswap01(int a,int b){
    int temp = a;
    a = b;
    b = temp;
}
void myswap02(int* a,int* b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
void myswap03(int &a,int &b){
    int temp = a;
    a = b;
    b = temp;
}
```

### 2.4 引用做函数的返回值

**作用:**引用是可以作为函数的返回值存在的

**注意：**不要返回局部变量引用

```c++
int& test01(){
    int a = 10;
    return a;
}//会出现问题，内存已经被释放
```

**用法：**函数调用可以作为作为左值

```c++
int& test02(){
    static int a = 10;
    return a;
}
test02()=1000; //相当于赋值操作
```

### 2.5 引用的本质

**本质：**引用的本质在C++内部实现是一个指针常量。

`int& ref = a`相当于`int* const ref = a`指针的指向不能修改，这也就证明了为什么初始化之后不能够修改指向，同时也可以证明为什么可以作为左值，因为其指向的空间的值是可以被修改的。

其操作是由编译器帮助完成的。

### 2.6 常量引用

**作用：**常量引用主要用来修饰形参，防止误操作

在函数形参列表中，可以加const修饰形参，防止形参改变实参

```c++
void showvalue(const int& v){
    v+=10;//注意，这一行在实际执行中报错，因为引用的是一个常量，不能被修改，这样就可以解决引用在某些莫名其妙的状况下被修改的问题。
    cout<<v<<endl;
}
```

## 3 函数高级

### 3.1 函数默认参数

在C++中，函数的形参列表中的形参是可以由默认值的

语法：`返回值类型 函数名 (形参 = 默认值){}`

如果我们自己传入参数，就用用户自己的数据，如果没有，就是用默认的数值。

注意：

1. 如果某个位置已经有了默认参数，那么从这个位置开始，从左向右都必须有默认值
2. 如果函数声明有默认参数，那么函数实现就不能有默认参数。

### 3.2 函数占位参数

C++中函数的形参列表中可以有展位参数，用来展位，调用函数时必须填补该位置

**语法：**`返回值类型 函数名(数据类型){}`

在现阶段函数的展位参数存在意义不大，但是后面的课程中会使用到该技术

展位参数也可以有默认参数。

### 3.3 函数重载



#### 3.3.1 函数重载概述

**作用：**函数名可以相同，提高复用性

**函数重载满足条件：**

* 同一个作用域下
* 函数名称相同
* 函数参数类型不同 或者 个数不同 或者 顺序不同

注意：==函数的返回值不可以做为函数重载的条件==

#### 3.3.2 函数重载注意事项

两个坑：

* 引用作为函数重载的条件==(int a 和 const int a可以作为重载条件)==
* 函数重载碰到函数默认参数(默认参数出现二义性，出错，尽量避免)

## 4 类和对象



C++面向对象的三大特性为：==封装、继承、多态==

C++认为==万事万物皆为对象==，对象上有其属性和行为

具有相同性质的对象，我们可以抽象称为==类==

### 4.1 封装



#### 4.1.1 封装的意义

封装是C++面向对象的三大特性之一

封装的意义：

* 将属性和行为作为一个整体，表现生活中的事物
* 将属性和行为加以权限控制

**封装意义一：**

在设计类的时候，属性和行为写在一起，表现事物

**语法：**`class 类名{ 访问权限: 属性 / 行为};`

> **类中的属性和行为称为成员**
>
> 属性 --> 成员属性 成员变量
>
> 行为 --> 成员函数 成员方法

**封装意义二：**

在设计类的时候，可以把属性和行为放在不同的权限下，加以控制

访问权限总共有三种：

公共权限 public  成员类内可以访问 类外也可以访问

保护权限 protected  成员类内可以访问 类外不可以访问 子也可以访问父中的保护内容

私有权限 private  成员类内可以访问 类外不可以访问 子不可以访问父的私有内容



#### 4.1.2 struct和class的区别

在C++中struct和class的唯一的区别在于 默认的访问权限不同

struct的默认权限位公共，而class的默认权限为似有



#### 4.1.3 成员属性设置为私有

优点1：将所有成员属性设置为私有，可以自己控制读写权限

优点2：对于写权限，我们可以检测数据的有效性

成员函数设置为公共，用于对外提供接口



### 4.2 对象的初始化和清理



* 生活中我们购买的电子产品基本会有出厂设置
* C++中面向对象来源于生活，每个对象都会有初始设置以及对象销毁前的清理数据的设置。



#### 4.2.1 构造函数和析构函数

对象的初始化和清理也是两个非常重要的安全问题

​				一个对象或者变量没有初始状态，对其使用后果未知

​				同样的，使用完一个对象或者变量，没有及时清理，也会造成一定的安全问题



C++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。对象的初始化和清理工作是编译器强制我们做的事情，因此如果我们不提供构造和析构函数，编译器会提供编译器提供的构造函数和析构函数是空实现。

* 构造函数：主要用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用。
* 析构函数：主要用于对象销毁前系统自动调用，执行一些清理工作

构造函数语法：`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以由参数，因此可以发生重载
4. 程序在调用对象的时候会自动调用构造，无需手动调用，而且只会调用一次

析构函数语法：`~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同，在名称前加上符号~
3. 析构函数不可以由参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构函数，无需手动调用，而且只会调用一次



#### 4.2.2 构造函数的分类以及调用

两种分类方式：

* 按参数分为：有参构造和无参(默认)构造
* 按类型分为：普通构造和拷贝构造

> 拷贝构造函数：类中某个对象的属性拷贝到另一个对象中

三种调用方式：

* 括号法

>  在使用默认构造函数的时候，不要加()，因为下面这行代码会被认为是一个函数的声明，而不会认为时创建对象

* 显示法

> 等号右边为匿名对象 `Person(10)` 特点:当前行执行结束后，系统会立即回收掉匿名的对象
>
> 不要利用拷贝构造函数初始化匿名对象，因为编译器会认为 person(p3)==person p3 重定义了
>
> 

* 隐式转换法

> person p4 = 10；person p5 = p4；



#### 4.2.3 拷贝构造函数调用时机

C++中拷贝构造函数调用时机通常有三种情况：

* 使用一个已经创建完毕的对象来初始化一个新对象
* 值传递的方式给函数参数传值

> 值传递时，会拷贝出一个副本进行值传递，实参传给形参的过程中进行的

* 以值方式返回局部对象

> 返回时根据原本的数据返回一个拷贝出来的副本数据，原本的局部对象调用完已经被析构了



#### 4.2.4 构造函数调用规则

默认情况下，C++编译器至少给一个类添加3个函数

1. 默认构造函数(无参数，函数体为空)
2. 默认析构函数(无参数，函数体为空)
3. 默认拷贝构造函数，对属性进行拷贝

构造函数调用规则如下：

* 如果用户定义有构造函数，C++不提供默认无参构造，但是会提供默认拷贝构造

* 如果用户定义拷贝构造函数，C++不会再提供其他构造函数



#### 4.2.5 深拷贝和浅拷贝

深浅拷贝是面试经典的问题，也是常见的一个面试坑

浅拷贝：简单的辅助拷贝操作

深拷贝：在堆区重新申请空间，进行拷贝操作

> 析构函数代码区的作用：将堆区开辟的内容释放干净
>
> 【!】==如果是浅拷贝，会出现堆区内容重复释放的问题！==
>
> 【解释】因为浅拷贝是将内容逐字拷贝到另一个对象中的，假设开辟了一个新的堆空间，当对象析构时，堆中的空间已经被释放。而当另一个对象调用析构函数时，堆该位置的空间已经被释放了，再次释放就产生了问题。
>
> 【解决方法】利用深拷贝，自己实现拷贝构造函数，解决浅拷贝的问题，直接在堆中开辟新的空间



#### 4.2.6 初始化列表

**作用：**C++提供了初始化列表的语法，用来初始化属性

**语法：**`构造函数():属性1 (值1),属性2(值2),…{}`



#### 4.2.7 类对象作为类成员

C++允许类中成员是另外一个类的对象，我们称该成员为 对象成员

例如：

```c++
class A {}
class B{
	A a;
}
```

B类中有对象A作为成员，A为对象成员

【Q】当创建B对象的时候，A与B的构造和析构函数顺序谁先谁后呢？

【A】先有A类的构造函数调用，后有B类的构造函数调用；析构的顺序与构造相反



#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数之前加上关键字static，称为静态成员

静态成员分为：

* 静态成员变量
  * 所有对象共享同一份数据
  * 在编译阶段分配内存
  * 类内声明，类外初始化
* 静态成员函数
  * 所有对象共享同一个函数
  * ==静态成员函数只能访问静态成员变量==

> 什么叫 类内声明 类外初始化？这是一个必须的操作
>
> ```C++
> class Person{
> public:
> 	static int m_A
> };
> int Person::m_A = 100;
> ```
>
> 这个数据是所有人共享的，不属于某个特定的对象，因此静态成员变量有两种访问的方式：
>
> 1. 通过对象进行访问
> 2. 通过类名进行访问
>
> 【注意】静态成员变量也是有访问权限的
>
> 静态成员函数显然只能调用访问静态成员变量，因为所有对象共享一个函数，函数本身不会知道是哪个特定的对象来调用，所以不能调用访问非静态成员变量，会出现问题



### 4.3 C++对象模型和this指针



#### 4.3.1 成员变量和成员函数分开存储

在C++中，类内的成员变量和成员函数分开存储

==只有非静态成员变量才会属于类的对象上！==

> C++编译器会给每一个空对象也分配1个字节空间，为的是区别空对象所占的内存位置，每个空对象都应该有一个独一无二的内存空间。

非静态成员函数也不会存储在类的对象上，他使用的方式是this指针



#### 4.3.2 this指针的概念

通过4.3.1，我们知道类内的成员变量和成员函数分开存储

每一个非静态成员函数指挥生成一份函数实例，也就是说多个同类型的对象会公用一段代码，那么，这一块代码是如何区分哪个对象调用的自己？

C++通过提供特殊的对象指针，**this指针**解决上述的问题，this指针**指向被调用的成员函数所属的对象**

this指针是隐含在每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可

this指针的用途：

* 当形参和成员变量同名时，可以用this指针来区分
* 在类的非静态成员函数中返回对象本身，可以使用`return *this`



#### 4.3.3 空指针访问成员函数

C++中允许空指针调用成员函数，但是要注意有没有用到this指针

如果用到了this指针，需要加以判断来保证代码的健壮性

> 如空指针指向涉及到访问数据内容的时候就会出问题



#### 4.3.4 const修饰成员函数

**常函数：**

* 成员函数后加const后我们称这个函数为常函数
* const加在成员函数的后面，修饰的是this指针，本身his指针的指向不允许修改但内容可以，现在限制this指针指向的内容也不允许修改
* 常函数内不可以修改成员属性
* 成员属性声明时候加关键字mutable后，在常函数中依然可以修改

**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数，因为普通成员函数可以修改属性，而假如允许调用普通成员函数就可以从侧面修改对象属性，这显然是不可以接受的



### 4.4 友元



生活中你家有客厅(public)，有你的卧室(private)

客厅所有来的客人都可以进去，但是你的卧室显然是私有的，也就是说只有你能进去，但是你也可以允许你的好朋友进入你的私人空间

在程序中，有些私有属性也是想让类外特殊的一些函数或者类进行访问，这就需要使用到友元这个技术

友元的关键字为==friend==

友元的三种实现

* 全局函数作为友元
* 类作为友元
* 成员函数作为友元



#### 4.4.1 全局函数作为友元



#### 4.4.2 类作为友元



#### 4.4.3 成员函数作为友元



### 4.5 运算符重载

### 4.6 继承

### 4.7 多态

## 5 文件操作
