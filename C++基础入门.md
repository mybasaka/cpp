# C++基础入门

### 1.C++初识

---

#### 1.1 第一个C++程序 hello world

#### 1.2 注释

// 和 /**/ 都可以作为注释，前者为单句，后者为多行

#### 1.3 变量

**作用**：给一段指定的内存空间命名，方便操作这段内存空间

**语法**：`数据类型 变量名 = 初始值`

#### 1.4 常量

**作用**：用于记录程序中不可更改的数据

C++常量定义的两种方式：

1. **#define**宏常量：`#define 常量名 常量值`
   * ==通常在文件上方定义==表示一个常量

2. **const**修饰的变量`const 数据类型 常量名 = 常量值`
   * ==通常在变量定义前加关键字const==，修饰该变量为常量，不可以修改。

#### 1.5 关键字

**作用**：关键字是C++中预先保留的单词（标识符）

* **在定义变量或者常量的时候，不能够使用关键字，否则会产生歧义**

C++的关键字如下：

![img](https://www.runoob.com/wp-content/uploads/2018/06/20130806104900234.jpg)



#### 1.6 标识符命名规则

**作用：**C++规定给标识符命名时，有一套自己的规则：

* 标识符不能是关键字
* 标识符只能由字母、数字、下划线组成
* 第一个字符必须是字母或者下划线
* 标识符中的字母区分大小写

> 建议：在给标识符命名时，争取做到见名知意，方便自己和他人阅读

### 2.数据类型

---

C++规定在创建变量或者常量的时候，必须指定相应的数据类型，否则没有办法分配内存，意义在于为数据类型分配合适的空间

#### 2.1 整型

**作用：** 整型变量表示是的是==整数类型==的数据

C++中能够表示整型的类型有以下几种方式，区别在于**占用的内存空间不同**

| 数据类型            | 占用空间 | 取值范围         |
| ------------------- | -------- | ---------------- |
| short(短整型)       | 2字节    | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节    | (-2^31 ~ 2^31-1) |
| long(长整型)        | 4 字节   | (-2^31 ~ 2^31-1) |
| long long(长长整型) | 8字节    | (-2^63~ 2^63-1)  |

#### 2.2 sizeof关键字

**作用：**利用sizeof关键字可以统计数据类型所占的内存大小

**语法：**`sizeof(数据类型/变量)`

#### 2.3 实型(浮点型)

**作用：**用于表示小数

浮点型变量分为两种

1. 单精度的float
2. 双精度的double

两者的区别在于有效数字的范围和数据的占据的内存长度不同

| 数据类型 | 占用空间 | 取值范围        |
| -------- | -------- | --------------- |
| float    | 4字节    | 7位有效数字     |
| double   | 8字节    | 15~16位有效数字 |

#### 2.4 字符型

**作用：**字符型变量用于显示单个字符

**语法：**`char ch = 'a'`

> 注意1： 在现实字符变量的时候，用单引号将字符括起来，不要使用双引号

> 注意2：单引号只能有一个字符，不可以是字符串

* C和C++中字符变量智能占用1个字节
* 字符型变量并不是吧字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元

#### 2.5 转义字符

**作用：**用于表示一些==不能显示出来的ASCII字符==

现阶段常用的转义字符有`\n \\ \t`

转义字符的原因是：某些字符在语句中会被误解为其他内容的字符，所以只能使用转义符号`\ `，注意到，转义字符和后面的内容是一体的。当然转义字符本身也不能独自存在，所以在表示`\`本身的时候要使用`\\`

![转义字符](https://bkimg.cdn.bcebos.com/pic/3bf33a87e950352ab1edf5555043fbf2b3118bdb?x-bce-process=image/resize,m_lfit,w_536,limit_1)

#### 2.6 字符串型

**作用：**用于表示一串字符

**两种风格**

1. **C风格字符串**：`char 变量名[] = "字符串值"`

> 注意：C风格的字符串要用双引号括起来

2. **C++风格的字符串**：`string 变量名 = “字符串值”`

> 注意：需要包含头文件`#include<string>`

#### 2.7 布尔类型 bool

**作用：** 布尔数据类型代表真或者假的值

bool类型只有两个值：

* True -- 真（本质是1）
* False -- 假（本质是0）

**bool类型占==1个字节==的大小**

#### 2.8 数据的输入输出

**作用：**用于从键盘获取数据和将数据输出到命令行/显示设备上

**关键字：**cin cout

**语法：**`cin >> 变量` `cout << 变量`

### 3 运算符

**作用：**用于执行代码的运算

| 运算符类型 | 作用                                     |
| ---------- | :--------------------------------------- |
| 算数运算符 | 用于处理四则运算                         |
| 赋值运算符 | 用于表达式的值赋值给变量                 |
| 比较运算符 | 用于表达式的比较，并返回一个真值或者假值 |
| 逻辑运算符 | 用于根据表达式的值返回真值或者假值       |

#### 3.1 算术运算符

**作用：** 用于处理四则运算

算术运算符包括以下符号：

`+ - (正负/加减) * / % ++ --(分为前置递增/减 和 后置递增/减) `

> 注意：前置递增是先增再输出，后置是现输出再递增 如以下例子
>
> `cout << a++;`这里输出的为a，在输出之后，a的值++
>
> `cout << ++a;`这里的输出为a+1

#### 3.2 赋值运算符

**作用：**用于并将表达式的值赋给变量

赋值运算符包括以下符号：

`= += -= *= /= %=`

#### 3.3 比较运算符

**作用：**用于表达式的比较，并返回一个真值或者假值

比较运算符包括以下符号：

`== != < > <= >=`

#### 3.4 逻辑运算符

**作用：**用于根据表达式的值返回真值或者假值

逻辑运算符有以下的符号：

`！ && ||`

#### 3.5 【补充】 C++ 运算符优先级

<img src="https://pic2.zhimg.com/v2-47e3ccc5d262631d2d3f44918791f47d_r.jpg" alt="img" style="zoom:67%;" />

### 4 程序流程结构

---

C/C++支持最基本的三种程序运行的结构：顺序结构、选择结构、循环结构

* 顺序结构：程序按照顺序执行、不发生跳转
* 选择结构：依据条件是否满足，有选择的执行相应的功能
* 循环结构：一句条件是否满足，循环多次执行某段代码

#### 4.1 选择结构

##### 4.1.1 if语句

**作用：**执行满足条件的语句

if语句的三种形式：

* 单行格式 `if {条件} {满足条件时执行的语句}`
* 多行格式 `if{条件} {满足条件执行的语句} else {不满足条件执行的语句}`
* 多条件if `if{条件1} {执行语句1} else if{条件2} {执行语句2} else{执行语句3}`

**嵌套if语句：**在if语句中，可以嵌套使用if语句，达到更加精确的条件判断

##### 4.1.2 三目运算符

**作用：**类似于if -else的条件判断，通过三目运算符实现简单的判断而不用写if else语句

**语法：**`表达式1 ? 表达式2 : 表达式3`

**解释：**如果表达式1的值为真，则执行表达式2，并返回结果；否则执行表达式3，并返回结果。

##### 4.1.3 switch语句

**作用：**执行多条件分支语句

```c++
switch{表达式}
{
    case 结果1: 执行语句;break;
    case 结果2: 执行语句;break;  
    ...
    default :执行语句;break;
}
```

#### 4.2 循环结构

##### 4.2.1 while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**`while{循环条件}{循环语句}`

**解释：**==只要循环条件的结果为真，就执行循环语句==

##### 4.2.2 do...while循环语句

**作用：**满足循环条件，执行循环语句

**语法：**`do{循环语句} while{循环条件}`

**解释：**与while的区别在于==do...while 会先执行一次循环语句，再判断循环条件==

##### 4.2.3 for循环语句

**作用：**满足循环条件，执行循环语句

**语法：**`for{起始表达式;条件表达式;末尾循环体} {循环语句;}`

> 注意：
>
> 1. for的条件表达式并不一定和起始终止现实的一致，可以在for中对另一些参数进行判断，比如，进行一个对数组元素累加的程序，虽然我的起始表达式和循环体都是用数组下标进行操作，但我可以使用count的变量判断结束的情况
>
> 2. for循环中，“初始化语句”、“条件语句”和“控制语句”都可以省略，但是其间的分号不能省略。同时，省略“条件语句”时，在for语句{}中必须包含跳出语句控制程序在某个条件满足时跳出for循环，否则将形成死循环 

##### 4.2.4 嵌套循环

**作用：**在循环之中再次嵌套新的循环

#### 4.3 跳转语句

##### 4.3.1 break语句

**作用：**用于跳出==选择结构==或者==循环结构==

break使用的时机：

* 出现在switch条件语句中，作用是种植case并跳出switch
* 出现在循环语句中，作用是跳出当前的循环
* 出现在嵌套循环语句中，跳出所在的那一层循环

##### 4.3.2 continue语句

**作用：**在==循环语句==中，跳过本次循环中余下的尚未执行的语句，继续执行下一次的循环

##### 4.3.3 goto语句

**作用：**可以无条件跳转语句

**语法：**`goto 标记;`

**解释：**如果标记的名称存在，执行goto语句时会跳转到标记的位置

> 注意：标记的形式和汇编语言中的形式类似

### 5 数组

---

#### 5.1 概述

数组是一个集合，里面存放了相同类型的数据元素

**特点1：**数组中每一个数据元素的类型是相同的

**特点2：**数组中的元素存放在连续的内存空间之中

#### 5.2 一维数组

##### 5.2.1 一维数组定义方式

有三种方式

1. `数据类型 数组名[数组长度]`
2. `数据类型 数组名[数组长度]={值1,值2,...}`
3. `数据类型 数组名 = {值1,值2,...}`

> 注意：数组的下标为从0开始的

##### 5.2.2 一维数组数组名

一维数组名称的用途：

1. 可以统计整个数组在内存中的长度
2. 可以获取数组在内存中的首地址

##### 5.2.3 冒泡排序算法

**作用：**最常用的排序算法 是一种交换排序 其作用是每次循环将循环中的最小或者最大的元素放到最终正确的位置，其思想像冒泡一样，将最小的内容放在数组的开始或者将最大的元素以类似石头沉底的方式一样放到数组的最底部

```c++
int * bubble_sort(int * arr,int size){
    bool flag = false; 
    //flag的作用是,若在内层循环中已经没有交换发生，则一定有序，flag可以减少循环的次数
    for(int i = 0; i < size ; i++){
        //这里我们采用将小的元素放置在上方的方法来进行排序
    	flag = false;
        for(int j = size - 1; j > i ;j--){
            int temp = arr[j];
            if (arr[j] < arr[j-1]){
                arr[j] = arr[j-1];
            	arr[j-1] = tmp;
                flag = true;
            }
        }
        if(flag == false) break;
    }
}
```

#### 5.3 二维数组

二维数组就是一维数组增加一个维度

##### 5.3.1 二维数组的定义方式

1. `数据类型 数组名[行数][列数];`
2. `数据类型 数组名[行数][列数] = {{数据1,数据2},{数据3 ,数据4}};`
3. `数据类型 数组名[行数][列数]={数据1,数据2,数据3,数据4};`
4. `数据类型 数组名[][列数]={数据1,数据2,数据3,数据4};`

##### 5.3.2 二维数组数组名

二维数组名称的用途：

1. 可以统计二维数组所占内存空间
2. 可以获取二维数组的首地址

### 6 函数

---

#### 6.1 概述

**作用：**将一段经常使用的代码封装起来，减少重复代码

一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能

#### 6.2 函数的定义

函数的定义有5个步骤

1. 返回值类型
2. 函数名
3. 参数表列
4. 函数体语句
5. return表达式

**语法：**

```
返回值类型 函数名 {参数列表}
{
	函数体语句
	
	return表达式
}
```

#### 6.3 函数的调用

**功能：**使用定义好的函数

**语法：**`函数名{参数}`

#### 6.4 值传递

* 所谓值传递，就是函数调用时实参将数值传入给形参
* 值传递时，==如果形参发生变化，并不会影响实参==

#### 6.5 函数常见的样式

常见的函数样式有4种

1. 无参无返
2. 有参无返
3. 无参有返
4. 有参有返

#### 6.6 函数的声明

**作用：**告诉编译器函数名称以及如何调用函数。函数的实际主体可以单独定义

* 函数的声明可以多次，但是函数的定义只能有一次

#### 6.7 函数的分文件编写

**作用：**让代码结构更加清晰

函数分文件编写一般有4个步骤：

1. 创建后缀名为.h的头文件
2. 创建后缀名为.cpp的源文件
3. 在头文件中写函数的声明
4. 在源文件中写函数的定义

### 7 指针

---

> *在数据类型的声明中是指指针，在表达式中，表示的是后者表示地址的内容。如`int * p`表示的是整数类型的指针，但是`* p`表示的则为p地址中的内容。
>
> 另外有`& a`表示的是a内容的地址

#### 7.1 指针的基本概念

**指针的作用：**可以通过指针间接访问内存

* 内存编号是从0开始记录的，一般用十六进制的数组表示
* 可以利用指针变量保存地址

#### 7.2 指针变量定义和使用

指针变量定义语法：`数据类型 * 变量名;`

#### 7.3 指针所占内存空间

提问：指针也是一种数据类型，那么这种数据类型占用多少内存空间？

回答：在32位操作系统下，占用4字节的空间，在64位操作系统下占用8字节。与操作系统有关，操作系统的位数为其所能处理的最大运算位数，一般内存的位数与其相匹。

#### 7.4 空指针和野指针

##### 7.4.1 空指针

**空指针：**指针变量指向内存中编号为0的空间

**用途：**初始化指针变量

**注意：**空指针指向的内存是不可访问的，访问空指针会报错

##### 7.4.2 野指针

**野指针：**指针变量指向非法的内存空间

野指针产生主要有两个原因：

1. 指针变量未初始化：任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。
2. 指针释放之后未置空：有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针删除。为什么野指针会产生错误呢？现在有指针int* a和一个变量int b;如果a没有赋值的话，他可能指向任意地方，假设它指向了b的地址，现在又使用了a的指向，如*a=c，那么就在无意间把b的值给改变了。产生野指针以上面第一个原因居多，可以按照以下方法避免：
   1. 定义指针后初始化为NULL;
   2. 使用前制定一个可用地址；
   3. 引用之前判断是否为NULL；
   4. 使用完后赋值为NULL。

#### 7.5 const修饰指针

==const修饰指针有三种情况：==

1. const修饰指针 --- **常量指针**

   在定义指针变量的时候，数据类型前面用const修饰，被定义的指针变量就是常量指针，格式为`const int * p = &a` 即，`* p = 9 操作错误 p = &b 操作成功`

   因为常量指针的本质为指针，并且这个指针是一个指向常量的指针，指针指向变量的值不能通过该指针修改，但是指针指向的值可以被改变

2. const修饰常量 --- **指针常量**

   顾名思义他是一个常量，但是是指针修饰的，其格式为：`int * const p = &a`   即，`*p = 9 操作成功 p = &b 操作错误`

   因为声明了指针常量，说明指针变量不允许修改。如果同次指针指向一个地址，该地址不能够被修改，但是地址中的内容是可以被修改的。

> 总结 ：
>
> 常量指针和指针常量两者的区别在与const到底修饰的是哪个东西
>
> 常量指针就是：常量的指针 （const修饰int）所以 指向的内容就不能被更改，因为其本质上是常量；
>
> 指针常量就是：指针是常量（const修饰指针）所以指向不能被改变，但是指向空间的内容是可以改变的。

3. const既修饰指针又修饰常量`const int * const p = & a `这样无论是指针还是指向的内容都不能被修改了

#### 7.6 指针和数组

**作用：**利用指针访问数组中的元素

**原理：**指针中的内容存放的是数组首地址，所以访问指针元素的内容访问的就是数组第一个元素。以int数组为例:

```C++
int arr[] = {1,3,6,9};
int * p = arr;
//* p = 1; * ( p + 1 ) = 3;
//+1的操作表示偏移1元素那么长空间
```

#### 7.7 指针和函数

**作用：**利用指针作为函数参数，可以修改实参的值

**原理：** 只修改形参内容的函数无法对实参产生影响，若想影响实参需要传入的是实参的地址，通过更改地址中的元素来实现可以直接对实参的内容进行修改。

注意到，函数的返回值也可以是一个指针类型的量

### 8 结构体

---

#### 8.1 结构体基本概念

结构体是属于用户==自定义的数据类型==，允许用户存储不同的数据类型

#### 8.2 结构体定义和使用

**语法：**`struct 结构体名 { 结构体成员列表 };`

通过结构体创建变量的方式有三种：

* struct 结构体名 变量名
* struct 结构体名 变量名 = {成员1值，成员2值... }
* 定义结构体时顺便创建变量

> 定义结构体时关键字struct不可以被省略，而创建结构体变量的时候是可以被省略的，结构体变量使用操作符 " . " 来访问成员。

#### 8.3 结构体数组

**作用：**将自定义的结构体放入到数组中方便维护

**语法：**`struct 结构体名 数组名[元素个数] = { {},{},...{} } `

#### 8.4 结构体指针

**作用：**通过指针访问结构体中的成员

* 利用操作符`->`可以通过结构体指针访问结构体的属性

#### 8.5 结构体嵌套结构体

**作用：**结构体中的成员可以是另一个结构体

#### 8.6 结构体做函数的参数

**作用：**将结构体作为参数向含函数中传递

传递的方式有两种：值传递 或 地址传递 （考虑形参和实参的区别）

#### 8.7 结构体中const使用的场景

**作用：**const使用来防止误操作

**原因：**在实际使用中，值传递会占用较大空间，所以一般都是指针传递，但是指针传递就需要考虑误操作的问题，所以需要养成传递指针的时候不允许实参发生变化的好习惯。(当然如果本意就是要修改实参的话不需要考虑这一点)



